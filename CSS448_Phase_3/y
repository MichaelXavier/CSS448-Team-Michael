%{

/* declarations section */
#include <iostream>
#include <string>
#include <queue>
#include <vector>
#include "STObject.h"
#include "actions.h"
#include "CPPGenerator.h"
using namespace std; 

extern void yyerror(const char *s);
extern int yylex();

extern string* errors;
extern bool has_errors;
extern int error_count;

STObject* symTable;

//CPPGenerator codegen(cout);
CPPGenerator codegen(cout);

//variable/const stuff
string name;
string type_name;
Constant* const_temp = NULL;
IdentRecord* ident_temp = NULL;
IdentRecord* type_ptr = NULL;
IdType current_idtype;
Procedure* proc_temp = NULL;
Parameter* param_temp = NULL;
PointerType* pointer_temp = NULL;
Constant* const_range_low = NULL;
Constant* const_range_high = NULL;
vector<PointerType*> pointer_list;
bool increment = true;

//helpers
ArrayHelper* array_helper = NULL;
ProgramHelper* program_helper = NULL;
RecordHelper* record_helper = NULL;
SetHelper* set_helper = NULL;
VarDecHelper* var_dec_helper = NULL;
ConstDecHelper* const_dec_helper = NULL;
queue<string> ident_queue;
queue<string> param_name_queue;//FIXME: added to keep a hold of params so we don't have to change ident_queue to a vector
queue<Constant*> const_queue;
queue<Parameter*> param_queue;
ProcedureHelper* procedure_helper = NULL;
FunctionHelper* function_helper = NULL;
PointerHelper* pointer_helper = NULL;


// for handling ranges
struct Range
{
	int lowInt;
	int highInt;
	bool lowBool;
	bool highBool;
	string lowString;
	string highString;
	string type;
};
Range* range_temp = NULL;
queue<Range*> ranges_queue;

// expressions
string expression = "";
string set_expression = "";
string designatorString = "";

// I/O
bool readingIO = false;
string IO_Operator = "";
bool readingIndices = false;

// array indices
queue<int>* arrayIndexQueue = NULL;

// function calls
bool allowFunctionCall = false;

extern string s;

%}

/* definition section */

%start  CompilationUnit
%token  yand yarray yassign ybegin ycaret ycase ycolon ycomma yconst ydispose 
        ydiv ydivide ydo  ydot ydotdot ydownto yelse yend yequal yfalse
        yfor yfunction ygreater ygreaterequal yident yif yin yleftbracket
        yleftparen yless ylessequal yminus ymod ymultiply ynew ynil ynot 
        ynotequal ynumber yof  yor yplus yprocedure yprogram yread yreadln  
        yrecord yrepeat yrightbracket yrightparen  ysemicolon yset ystring
        ythen  yto ytrue ytype  yuntil  yvar ywhile ywrite ywriteln yunknown

%%
/* rules section */

/**************************  Pascal program **********************************/

CompilationUnit    :  ProgramModule 
                      {
                        codegen.teardown();
                        codegen.print();
                        endProgram();
                      }
                   ;
ProgramModule      :  yprogram 
                      yident 
                      {
                        program_helper = new ProgramHelper(s);
                        codegen.setup();
                      } 
                      ProgramParameters ysemicolon 
                      {
                        startProgram(program_helper->GetProgramObj());
                      }
                      Block ydot
                      {
                        delete program_helper; program_helper = NULL;
                      }
                   ;
ProgramParameters  :  yleftparen  IdentList  
                      yrightparen
                      {
                        codegen.defineIO(ident_queue);
                        program_helper->AddParameterNames(ident_queue);
                      } 
                   ;
IdentList          :  yident 
                      { 
                        ident_queue.push(s);
                      }
                   |  IdentList ycomma yident
                      {
                        ident_queue.push(s);
                      }
                   ;

/**************************  Declarations section ***************************/

Block              :  Declarations  ybegin  StatementSequence  yend
                   ;
Declarations       :  ConstantDefBlock              /* you do this one */
                      TypeDefBlock
                      VariableDeclBlock             /* you finish this one */
                      SubprogDeclList  
                   ;
ConstantDefBlock   :  /*** empty ***/                                  /* you finish it */
                   |  yconst  
                      ConstantDefList
                   ;
ConstantDefList    :  ConstantDef 
                      ysemicolon
                   |  ConstantDefList ConstantDef 
                      ysemicolon
                   ;
TypeDefBlock       :  /*** empty ***/
                   |  ytype  TypeDefList          
                      {/* checkPointers(declared_ptr_helpers);*/}
                   ;
TypeDefList        :  TypeDef  ysemicolon
                   |  TypeDefList TypeDef ysemicolon  
                   ;
VariableDeclBlock  :  /*** empty ***/
                   |  yvar 
                      VariableDeclList
                   ;
VariableDeclList   :  VariableDecl ysemicolon
                   |  VariableDeclList VariableDecl ysemicolon /*ADDED: recursive case*/
                   ;  
ConstantDef        :  yident 
                      {
                        const_dec_helper = new ConstDecHelper();
                        const_dec_helper->setConstName(s);
                      } 
                      yequal  ConstExpression
                      { 
                        const_dec_helper->setConstObj(const_temp);
                        codegen.declareConst(const_dec_helper, const_temp);
                        delete const_temp;
                        const_temp = NULL;
                        const_dec_helper->sendToSt(symTable);
                        delete const_dec_helper;
                        const_dec_helper = NULL;
                      }
                   ;
TypeDef            :  yident
                      {
                        name = s;
                      }
                      yequal Type
                      {
                        resolvePointers(type_ptr, pointer_list);                     
                      }
                   ;
                   
VariableDecl       :  {
                        var_dec_helper = new VarDecHelper();
                      } 
                      IdentList  ycolon 
                      Type
                      {
                        if (type_ptr != NULL) {
                          codegen.declareVars(ident_queue, type_ptr);
                          var_dec_helper->SetMemberType(type_ptr);
                          var_dec_helper->AddVars(ident_queue);
                          var_dec_helper->sendToSt(symTable);
                          while (!ident_queue.empty()) { ident_queue.pop(); }
                        } else {
                          cout << "Error: variable(s) being declared have undefined type: ";
                          while (!ident_queue.empty()) { cout << ident_queue.front() << ", "; ident_queue.pop(); }
                        }
                        delete var_dec_helper;
                        var_dec_helper = NULL;
                      }
                   ;

/***************************  Const/Type Stuff  ******************************/

ConstExpression    :  UnaryOperator  ConstFactor
                   |  ConstFactor
                   |  ystring 
                      {
                        const_temp = new Constant("");
                        const_temp->setConstFactor(s);
                      }
                   ;
ConstFactor        :  yident
                      {
                          ident_temp = symTable->lookup(s);	
                          if(ident_temp == NULL) {
                            cout << "Error: unable to locate temporary ident for this constant given the name " << s << endl;
                          } else {
                            Constant* findConst = static_cast<Constant*>(ident_temp);
                            string constType = findConst->getConstType();
                            
                            const_temp = new Constant("");
                          
                            if (constType == "s") {
                              const_temp->setConstFactor(findConst->getConstString());
                            } else if(constType == "b") {
                              const_temp->setConstFactor(findConst->getConstBool());
                            } else if(constType == "i") {
                              const_temp->setConstFactor(findConst->getConstInt());
                            } else {
                              cout << "Error: cannot handle constant with an invalid constType " << constType << endl;
                            }
                        }
                      }
                   |  ynumber
                      {
                        const_temp = new Constant("");//anonymous constant

                        int parsed_int = 0;            
                        if (strToInt(s, parsed_int)) {
                          const_temp->setConstFactor(parsed_int);
                        } else {
                          const_temp->setConstFactor(parsed_int);
                        }                      
                      }
                   |  ytrue
                      {
                        const_temp = new Constant("");
                        const_temp->setConstFactor(true);
                      }
                   |  yfalse
                      {
                        const_temp = new Constant("");
                        const_temp->setConstFactor(true);
                      }
                   |  ynil
                      {
                        const_temp->setConstFactor(static_cast<IdentRecord*>(NULL));
                      } /*FIXME: unsure about this*/
                   ;

                   ;
Type               :  yident 
                      {
                        type_ptr = symTable->lookup(s);
                      }
                   |  ArrayType
                   |  PointerType
                   |  RecordType
                   |  SetType 
                   ;
ArrayType          :  yarray 
                      {
                        array_helper = new ArrayHelper(name);
                      } 
                      yleftbracket Subrange SubrangeList /*Subrange pushes on stack, wait till entire list is done*/
                      {
                        while(ranges_queue.size() != 0) {
                          Range* currentRange = ranges_queue.front();
                          ranges_queue.pop();
                          if (currentRange->type == "i") {
                            array_helper->addDimension(currentRange->lowInt, currentRange->highInt);
                          } else if (currentRange->type == "b") {
                            array_helper->addDimension(currentRange->lowBool, currentRange->highBool);
                          } else if (currentRange->type == "s") {
                            array_helper->addDimension(currentRange->lowString, currentRange->highString);
                          }
                          delete currentRange;
                          currentRange = NULL;
                        }
                      }
                      yrightbracket  yof Type 
                      { 
                        array_helper->setTypePtr(type_ptr);
                        type_ptr = NULL;//set it null so we don't delete it later
                        /*will fail validation if there's a problem*/
                        type_ptr = array_helper->sendToSt(symTable);
                        codegen.declareArray(array_helper);
                        delete array_helper; 
                        array_helper = NULL;
                      }
                   ;

SubrangeList       :  
                   |  SubrangeList ycomma Subrange 
                   ;
Subrange           :  {
                        range_temp = new Range;
                      } 
                      ConstFactor
                      {
                        string constType = const_temp->getConstType();
                        if(constType == "s")
                        {
                          range_temp->lowString = const_temp->getConstString();
                          range_temp->type = "s";
                        }
                        else if(constType == "b")
                        {
                          range_temp->lowBool = const_temp->getConstBool();
                          range_temp->type = "b";
                        }
                        else if(constType == "i")
                        {
                          range_temp->lowInt = const_temp->getConstInt();
                          range_temp->type = "i";
                        }
                        delete const_temp;
                        const_temp = NULL;
                      }	
                      ydotdot
                      ConstFactor 
                      {
                        string constType = const_temp->getConstType();
                        if(constType == "s")
                        {
                          range_temp->highString = const_temp->getConstString();
                          range_temp->type = "s";
                        }
                        else if(constType == "b")
                        {
                          range_temp->highBool = const_temp->getConstBool();
                          range_temp->type = "b";
                        }
                        else if(constType == "i")
                        {
                          range_temp->highInt = const_temp->getConstInt();
                          range_temp->type = "i";
                        }
                        ranges_queue.push(range_temp);
                        range_temp = NULL;
                        delete const_temp;
                        const_temp = NULL;
                      }
                   |  ystring 
                      {
                        deleteSingleQuote(s);
                        range_temp = new Range; 
                        range_temp->lowString = s;
                        range_temp->type = "s";
                      } 
                      ydotdot  ystring
                      {
                        deleteSingleQuote(s);
                        range_temp->highString = s;
                        ranges_queue.push(range_temp);
                        range_temp = NULL;
                        delete const_temp;
                        const_temp = NULL;
                      } 
                   ;
RecordType         :  yrecord 
                      {record_helper = new RecordHelper(name);} 
                      FieldListSequence  
                      {
                        codegen.declareRecord(record_helper);
                        type_ptr = record_helper->sendToSt(symTable);
                        delete record_helper;
                        record_helper = NULL;
                      }
                      yend 
                   ;
SetType            :  yset 
                      {
                        set_helper = new SetHelper(name);
                      }
                      yof  Subrange 
                      { 
                        Range* currentRange = ranges_queue.front();
                        ranges_queue.pop();
                        /*if (currentRange->type == "i") {
                          set_helper->setRange(currentRange->lowInt, currentRange->highInt);
                        } else if (currentRange->type == "b") {
                          set_helper->setRange(currentRange->lowBool, currentRange->highBool);
                        } else if (currentRange->type == "s") {
                          set_helper->setRange(currentRange->lowString, currentRange->highString);
                        }*/
                        //FIXME: I believe only integers are allowed as set members
                        if (currentRange->type == "i") {
                          set_helper->setRange(currentRange->lowInt, currentRange->highInt);
                          /*will fail validation if there's a problem*/
                          type_ptr = set_helper->sendToSt(symTable);
                          if (type_ptr != NULL) {
                            codegen.declareSetType(name, currentRange->lowInt, currentRange->highInt);
                          }
                        } else {
                          cout << "Error: invalid member for declared set." << endl;
                        }
                        delete set_helper; 
                        set_helper = NULL;
                        delete currentRange;
                        currentRange = NULL;
                      }					  
                   ;
PointerType        :  ycaret
                      yident 
                      {
                        pointer_helper = new PointerHelper(name); /*name is matched in the caling rule*/
                        pointer_helper->setDeclaredType(s);/*get the name of what it's supposed to point to*/
                        pointer_helper->sendToSt(symTable);
                        codegen.declarePointer(pointer_helper);
                        delete pointer_helper;
                        pointer_helper = NULL;
                        
                        type_ptr = symTable->lookup(name);
                        pointer_temp = static_cast<PointerType*>(type_ptr);
                        pointer_list.push_back(pointer_temp);
                      } 
                   ;
FieldListSequence  :  FieldList 
                   |  FieldListSequence  ysemicolon  FieldList
                   ;
FieldList          :  IdentList 
                      {
                        for(int i = 0; i < ident_queue.size(); i++) {
                          string cur_ident = ident_queue.front();
                          record_helper->addFieldName(cur_ident); 
                          ident_queue.pop();
                        }
                      }
                      ycolon Type 
                      {
                        record_helper->setCurrentFieldType(type_ptr);
                        record_helper->addFields(symTable);
                      }
                   ;

/***************************  Statements  ************************************/

StatementSequence  :  Statement
                   |  StatementSequence  ysemicolon Statement
                   ;
Statement          :  Assignment
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  ProcedureCall
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  IfStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  CaseStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  WhileStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  RepeatStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  ForStatement
                   |  IOStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  MemoryStatement
                   	  {
                         codegen.writeStr(";\n");
                      } 
                   |  ybegin 
                   	  {
                         codegen.startBlock();
                      } 
                      StatementSequence yend
                   	  {
                         codegen.endBlock();
                      } 
                   |  /*** empty ***/
                   ; 
Assignment         :  Designator yassign 
                      {
                        expression += " = ";
                        allowFunctionCall = true;
                      } 
                      Expression
                      { 
                        //designatorString captures the name of the var, if LHS is undefined, dont continue
                        //FIXME: LHS checking disabled, we build up the pointer strik to the point where we can't resolve it
                        //if (symTable->lookup(designatorString) != NULL) {
                          codegen.writeStrWI(expression);
                        //} else {
                          //cout << "Error: LHS of expression '" << expression << "' is undefined." << endl;
                        //}
                        designatorString = "";
                        expression = "";
                        allowFunctionCall = false;
                      }
                   ;
ProcedureCall      :  yident 
                      {
                        if (symTable->lookup(s) == NULL) {
                          cout << "Error: no procedure exists with name " << s << endl;//FIXME: check if its a proc?
                        } else {
                          codegen.callProc(s, "");
                        }
                      }
                   |  yident 
                      { 
                        name = s;
                      }
                      ActualParameters
                      {
                        if (symTable->lookup(s) == NULL) {
                          cout << "Error: no procedure exists with name " << s << endl;//FIXME: check if its a proc?
                        } else {
                          codegen.callProc(name, expression);
                        }
                        expression = "";
                      }
                   ;
IfStatement        :  yif  
                      { 
                        codegen.startIfExpr();
                      }
                      Expression  
                      {
                        codegen.writeStr(expression); 
                        expression = "";
                        codegen.closeIfExpr();
                        codegen.startBlock();
                      }
                      ythen  Statement  
                      {
                        codegen.endBlock();
                      }
                      ElsePart
                   ;
ElsePart           :  /*** empty ***/
                   |  yelse 
                      {
                        codegen.startElseExpr();
                      }
                      Statement  
                      {
                        codegen.endBlock();
                        /*FIXME: ends up with an extra curly brace*/
                      }
                   ;
CaseStatement      :  ycase 
                      {
                        codegen.startCase();
                      } 
                      Expression 
                      {
                        codegen.writeStr(expression + ")"); 
                        expression = "";
                        codegen.startBlock();
                      }
                      yof  CaseList  yend
                      {
                        codegen.endBlock();
                      }
                   ;
CaseList           :  Case
                      {
                        codegen.breakCase();
                      }
                   |  CaseList  ysemicolon  Case  
                      {
                        codegen.breakCase();
                      }
                   ;
Case               :  CaseLabelList  ycolon  Statement
                   ;
CaseLabelList      :  ConstExpression 
                      {
                        if (const_temp->getConstType() == "s" && const_temp->getConstString().length() > 1) {
                          cout << "Error: Cannot have a case statement with a length > 0" << endl;
                        } else {
                          codegen.writeCaseLabel(const_temp);
                        }
                        delete const_temp;
                        const_temp = NULL;  
                      }
                   |  CaseLabelList  ycomma  ConstExpression    
                   ;
WhileStatement     :  ywhile  
                      {
                        codegen.startWhile();
                      }
                      Expression
                      {
                        codegen.writeStr(expression + ")"); 
                        expression = "";
                      }
                      ydo  
                      {
                        codegen.startBlock();
                      }
                      Statement  
                      {
                        codegen.endBlock();
                      }
                   ;
RepeatStatement    :  yrepeat
                      {
                        codegen.startRepeat();
                      }
                      StatementSequence  yuntil  Expression
                      {
                        codegen.closeRepeat(expression);
                        expression = "";
                      }
                   ;
ForStatement       :  yfor  yident 
                      {
                        expression += s;
                        name = s;//Store for later 
                      }
                      yassign 
                      {
                        expression += " = ";
                      }  
                      Expression  
                      {
                      	expression = expression.substr(0, expression.length() - s.length());
						s = convertDoubleQuote(s);
						expression += s;
                        codegen.startFor(expression);
                        expression = "";
                      }
                      WhichWay  Expression
                      {
                      	expression = expression.substr(0, expression.length() - s.length());
						s = convertDoubleQuote(s);
						expression += s;
                        codegen.completeFor(name, expression, increment);
                        expression = "";
                        name = "";
                        codegen.startBlock();
                      }
                      ydo  Statement
                      {
                        codegen.endBlock();
                      }
                   ;
WhichWay           :  yto  
                      {
                        increment = true;
                      }
                   |  ydownto
                      {
                        increment = false;
                      }
                   ;
IOStatement        :  yread {readingIO = true; IO_Operator = " >> "; allowFunctionCall = false;}
                      yleftparen  DesignatorList  yrightparen 
                      {
                        codegen.cinExpr(expression, false);
                        expression = "";
                        readingIO = false;
                      }
                   |  yreadln
                      {
                        codegen.cinLn();
                      }
                   |  yreadln {readingIO = true; IO_Operator = " >> "; allowFunctionCall = false;}
                      yleftparen DesignatorList  yrightparen 
                      {
                        codegen.cinExpr(expression, true);
                        expression = "";
                        readingIO = false;
                      }
                   
                   |  ywrite {readingIO = true; IO_Operator = " << ";}  
                      yleftparen  ExpList  yrightparen
                      {
                        codegen.coutExpr(expression, false);
                        expression = "";
                        readingIO = false;
                      } 
                   |  ywriteln
                      {
                        codegen.coutLn();
                      }
                   |  ywriteln {readingIO = true; IO_Operator = " << ";} 
                      yleftparen ExpList 
                      {
                        codegen.coutExpr(expression, true);
                        expression = "";
                        readingIO = false;
                      } 
                      yrightparen  
                   ;

/***************************  Designator Stuff  ******************************/

DesignatorList     :  Designator  
                      {
                        designatorString = "";
                      }
                   |  DesignatorList  ycomma 
                      {
                        if(readingIO == true) {
                          expression += IO_Operator;
                        } else { 
                          expression += ", ";
                        }
                      }  
                      Designator 
                      {
                        designatorString = "";
                      }
                   ;
Designator         :  yident 
                      {
                        expression += s;
                        designatorString = s;
                        
                        /**/
                        if(readingIndices == true && arrayIndexQueue != NULL)
                        {
                          int offset = arrayIndexQueue->front();
                          arrayIndexQueue->pop();
                          expression += "-";
                          string offsetString;
                          intToString(offsetString, offset);
                          expression += offsetString;
                        }
						/**/
                      } 
                      DesignatorStuff 
                   ;
DesignatorStuff    :  /*** empty ***/
                   |  DesignatorStuff  theDesignatorStuff
                   |  ActualParameters 
                      { 
                        if(allowFunctionCall == false) {
                          cout << "Error: incorrect function call.";
                        }
                      }
                   ;
theDesignatorStuff :  ydot 
                   
                      {
                        expression += ".";
                      } 
                      yident 
                      {
                        expression += s; designatorString = s;
                      }
                   |  yleftbracket 
                      {
                        expression += "[";
                        readingIndices = true;
                        
                        /**/
                        // Checks if the indices are of an array, in order to calculate index offsets
                        IdentRecord* temp = symTable->lookup(designatorString);
                        if (temp != NULL) {
                          if(temp->getInstanceName() == "Variable")
                          {	
                            Variable* tempVar = static_cast<Variable*>(temp);
                            if(tempVar->getTypePtr()->getInstanceName() == "ArrayType")
                            {
                              ArrayType* tempArray = static_cast<ArrayType*>(tempVar->getTypePtr());
                              arrayIndexQueue = tempArray->getLowRangeValues();
                              tempArray = NULL;
                            }
                            tempVar = NULL;
                          }
                          temp = NULL; 
                        }
                        /**/
						
                      } 
                      ExpList yrightbracket 
                      {
                        expression += "]";
                        readingIndices = false;

                        if(arrayIndexQueue != NULL) {
                          while(!arrayIndexQueue->empty()) {
                            arrayIndexQueue->pop();
                          }
                          delete arrayIndexQueue;
                          arrayIndexQueue = NULL;
                        }
                      } 
                   |  ycaret 
                      {
                        expression = expression.substr(0, expression.length() - designatorString.length());
                        expression += "(*";
                        expression += designatorString;
                        expression += ")";
                      }
                   ;
ActualParameters   :  yleftparen  
                      {
                      expression += "("; 
                      }
                      ExpList  yrightparen
                      {
                      expression += ")"; 
                      }
                   ;
ExpList            :  Expression   
                   |  ExpList  ycomma 
                      { 
                        if(readingIndices == true) {
                          expression += "][";
                        } else if(readingIO == true) {
                          expression += IO_Operator;
                        } else {
                          expression += ", ";
                        }
                      }  Expression       
                   ;
MemoryStatement    :  ynew  yleftparen  yident
                      {
                        codegen.allocVar(s);
                      }
                      yrightparen  
                   |  ydispose yleftparen  yident  
                      {
                        codegen.deallocVar(s);
                      }
                      yrightparen
                   ;

/***************************  Expression Stuff  ******************************/

Expression         :  SimpleExpression
                   |  SimpleExpression  Relation  SimpleExpression 
                   ;
SimpleExpression   :  TermExpr
                   |  UnaryOperator  TermExpr
                   ;
TermExpr           :  Term  
                   |  TermExpr  AddOperator  Term
                   ;
Term               :  Factor  
                   |  Term  MultOperator  Factor
                   ;
Factor             :  ynumber 
                      {
                        expression += s;
                        /**/ 
                        if(readingIndices == true && arrayIndexQueue != NULL)
                        {
                          int offset = arrayIndexQueue->front();
                          arrayIndexQueue->pop();
                          expression += "-";
                          string offsetString;
                          intToString(offsetString, offset);
                          expression += offsetString;
                        } 
                        /**/ 
                      }
                   |  ytrue 
                      {
                        expression += "true";
                      }
                   |  yfalse 
                      {
                        expression += "false";
                      }
                   |  ynil 
                      {
                        expression += "NULL";
                      }
                   |  ystring 
                      {
                        expression += convertSingleQuote(s);
                        /**/ 
                        if(readingIndices == true && arrayIndexQueue != NULL)
                        {
                          int offset = arrayIndexQueue->front();
                          arrayIndexQueue->pop();
                          expression += "-";
                          expression += offset;
                        }
                        /**/
                      }
                   |  Designator
                   |  yleftparen 
                      {
                        expression += "(";
                      }  
                      Expression  yrightparen 
                      {
                        expression += ")";
                      }
                   |  ynot 
                      {
                        expression += "!";
                      }
                      Factor 
                   |  Setvalue
                      {
                        expression += convertSetExpr(set_expression);
                        set_expression = "";
                      }
                   ;
Setvalue           :  yleftbracket  ElementList  yrightbracket
                   |  yleftbracket yrightbracket
                   ;
ElementList        :  Element  
                   |  ElementList  ycomma
                      {
                        set_expression += ",";
                      }
                      Element
                   ;
Element            :  ConstExpression  
                      {
                        if (const_temp != NULL) {
                          set_expression += const_temp->toString();
                        }
                      }


                   |  ConstExpression
                      {
                        if (const_temp != NULL) {
                          set_expression += const_temp->toString();
                        }
                      }
                      ydotdot
                      {
                        set_expression += "..";
                      }
                      ConstExpression 
                      {
                        if (const_temp != NULL) {
                          set_expression += const_temp->toString();
                        }
                      }
                   ;

/***************************  Subprogram Stuff  ******************************/

SubprogDeclList    :  /*** empty ***/
                   |  SubprogDeclList ProcedureDecl ysemicolon  
                   |  SubprogDeclList FunctionDecl ysemicolon
                   ;
ProcedureDecl      :  ProcedureHeading 
                      {
                        type_ptr = procedure_helper->sendToSt(symTable);
                        if (type_ptr != NULL) {
                          //codegen it
                          //codegen.declareProc(type_ptr->getName(), param_name_queue);
                          codegen.declareProc(type_ptr->getName(), *procedure_helper);
                          //clear param queue
                          while (!param_name_queue.empty()) { param_name_queue.pop(); }
                          while (!param_queue.empty()) { param_queue.pop(); }
                        }
                        delete procedure_helper;
                        procedure_helper = NULL;
                        type_ptr = NULL;
                      }
                      ysemicolon  Block
                      { 
                        codegen.closeScope();//close function scope on codegen
                        checkPointers(pointer_list);
                        symTable->scopeExit();
                      }
                   ;
FunctionDecl       :  FunctionHeading  
                      ycolon  yident
                      {
                        IdentRecord* tempPtr = symTable->lookup(s);
                        if(tempPtr != NULL) {
                          function_helper->SetReturnType(tempPtr);
                          type_ptr = function_helper->sendToSt(symTable);
                          //codegen it
                          if (type_ptr != NULL) {
                            //codegen.declareFunct(type_ptr->getName(), param_name_queue, tempPtr->getName());
                            codegen.declareFunct(type_ptr->getName(), *function_helper);
                            //clear param queue
                            while (!param_name_queue.empty()) { param_name_queue.pop(); }
                            while (!param_queue.empty()) { param_queue.pop(); }
                            type_ptr = NULL;
                          } else  {
                            cout << "Error: function failed to insert into the ST." << endl;
                          }
                        } else {
                          cout << "Error: function return type is incorrect" << endl;
                        }
                        delete function_helper;
                        function_helper = NULL;
                      }
                      ysemicolon  Block
                      { 
                        codegen.closeFunct();//FIXME: experimental
                        //codegen.closeScope();//close function scope on codegen
                        checkPointers(pointer_list);
                        symTable->scopeExit();
                      }
                   ;
ProcedureHeading   :  yprocedure  yident  
                      {
                        procedure_helper = new ProcedureHelper(s);
                      }
                   |  yprocedure  yident  
                      {
                        procedure_helper = new ProcedureHelper(s);
                      }
                      FormalParameters
                      {
                        procedure_helper->AddParameters(param_queue);
                      }
                   ;
FunctionHeading    :  yfunction  yident  
                      {
                        function_helper = new FunctionHelper(s);
                      }
                   |  yfunction  yident  
                      {
                        function_helper = new FunctionHelper(s);
                      }
                      FormalParameters
                      {
                        function_helper->AddParameters(param_queue);
                      }
                   ;
FormalParameters   :  yleftparen FormalParamList yrightparen 
                   ;
FormalParamList    :  OneFormalParam  /* nothing to do here */
                   |  FormalParamList ysemicolon OneFormalParam
                   ;
OneFormalParam     :  yvar  IdentList /* have the param names now */
                      ycolon  yident
                      {
                        ident_temp = symTable->lookup(s);
                        //copy for codegen
                        param_name_queue = ident_queue;
                        while(!ident_queue.empty()) {
                          Parameter* param = new Parameter(ident_queue.front());
                          param->setTypePtr(ident_temp);
                          param_queue.push(param);
                          ident_queue.pop();
                        }
                        ident_temp = NULL;//set it null so we don't delete it later
                      }
                   |  IdentList  /* have the param names now */
                      ycolon  yident
                      {
                        ident_temp = symTable->lookup(s);
                        while(!ident_queue.empty()) {
                          Parameter* param = new Parameter(ident_queue.front());
                          param->setTypePtr(ident_temp);
                          param_queue.push(param);
                          ident_queue.pop();
                        }
                        ident_temp = NULL;//set it null so we don't delete it later
                      }
                   ;

/***************************  More Operators  ********************************/

UnaryOperator      :  yplus 
                      {
                        expression += "+";
                      } 
                   |  yminus 
                      {
                        expression += "-";
                      } 
                   ;
MultOperator       :  ymultiply 
                      {
                        expression += " * ";
                      } 
                   |  ydivide 
                      {
                        expression += " / ";
                      } 
                   |  ydiv 
                      {
                        expression += " / ";
                      } 
                   |  ymod 
                      {
                        expression += " % ";
                      }
                   |  yand 
                      {
                        expression += " && ";
                      }
                   ;
AddOperator        :  yplus 
                      {expression += " + ";}
                   |  yminus 
                      {
                        expression += " - ";
                      }
                   |  yor 
                      {
                        expression += " || ";
                      }
                   ;
Relation           :  yequal 
                      {
                        expression += " == ";
                      }
                   |  ynotequal 
                      {
                        expression += " != ";
                      }
                   |  yless 
                      {
                        expression += " < ";
                      }
                   |  ygreater 
                      {
                        expression += " > ";
                      } 
                   |  ylessequal 
                      {
                        expression += " <= ";
                      }
                   |  ygreaterequal 
                      {
                        expression += " >= ";
                      }
                   |  yin 
                   ;

%%

/* program section */

void yyerror(const char *s) {
   cout << s << endl;
}

extern int yylex();

